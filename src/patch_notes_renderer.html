<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <link href="/favicon.png" rel="icon" type="image/png"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="#ce0000" name="theme-color">
    <meta content="Red DF | Patch Note Renderer" name="title">
    <meta content="Render patch notes from text" name="description">
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <link href="./style.css" rel="stylesheet">
    <title>Red DF</title>
</head>
<body class="bg-gray-950 text-white">
<nav class="bg-gray-800">
    <div class="max-w-7xl px-2 sm:px-6 lg:px-8">
        <div class="relative flex h-16 items-center justify-between">
            <div class="flex flex-1 items-stretch justify-start">
                <div class="ml-6">
                    <div class="flex space-x-4">
                        <a class="nav-item" href="/">Home</a>
                        <a class="nav-item" href="/color_palette">Color Palette</a>
                        <a class="nav-item" href="#">Template Splitter</a>
                        <a class="nav-item" href="/text_file_to_template">Text File to Template</a>
                        <a class="nav-item" href="#">Skin Pixel Art Generator</a>
                        <a class="nav-item nav-selected-item" href="#">Patch Notes Renderer</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
</nav>

<main>
    <header>
        <h1>Patch Notes Renderer</h1>
        <h2>Render Patch Notes</h2>
    </header>

    <div class="grid grid-cols-2 justify-evenly items-start">
        <div>
            <textarea autocomplete="off" class="bg-gray-600 text-white rounded-sm font-mono w-full"
                      id="patch_notes_input" placeholder="Enter patch notes data"
                      rows="25">
! 6.6 &r&aepic version
@ June 13, 2024

> Example patch

Hello! This uses legacy color codes, even the prefixes use them, so you can do stuff like &chello!, &leven bold! &oor italic.. &acolors reset decorations as expected, &r&&rr resets to orange instead of white.

# Example Header
* CRAZY new feature
^ This crazy feature is CRAZY!!

# Another Header
+ Yeah another feature
+ &mYet another one.
- Never mind, removed the yet another one

# Bug  Fixes!?
~ We never fix bugs
~ Get trolled.

> Note, the text and line rendering is pretty blurry.. I've changed every possible setting to make it not blurry, but I guess I am just not that cool.</textarea>
        </div>
        <div class="flex flex-col justify-center">
            <canvas class="bg-gray-800 border border-gray-700" height="1000" id="patch_notes_canvas"
                    width="800"></canvas>
        </div>
    </div>

</main>

<script src="./main.js" type="module"></script>
<script type="module">
    // Get references to the input and canvas elements
    const patchNotesInput = document.getElementById('patch_notes_input');
    const patchNotesCanvas = document.getElementById('patch_notes_canvas');
    const ctx = patchNotesCanvas.getContext('2d');

    // Event listener for input changes
    patchNotesInput.addEventListener('input', () => {
        const data = patchNotesInput.value;
        const lines = data.split('\n');
        renderPatchNotes(lines);
    });

    window.addEventListener('load', () => {
        const data = patchNotesInput.value;
        const lines = data.split('\n');
        renderPatchNotes(lines);
    });

    function darkenHexColor(hex, percent) {
        // Ensure the hex string is in the format "#RRGGBB"
        if (hex.length !== 7 || hex[0] !== '#') {
            throw new Error('Invalid hex color format. Use #RRGGBB.');
        }

        // Parse the hex color
        let r = parseInt(hex.slice(1, 3), 16);
        let g = parseInt(hex.slice(3, 5), 16);
        let b = parseInt(hex.slice(5, 7), 16);

        // Darken each color component by the given percentage
        r = Math.floor(r * (1 - percent / 100));
        g = Math.floor(g * (1 - percent / 100));
        b = Math.floor(b * (1 - percent / 100));

        // Ensure the values are within the valid range [0, 255]
        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        b = Math.max(0, Math.min(255, b));

        // Convert the color components back to hex and return the result
        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }


    // Function to render patch notes on the canvas
    const renderPatchNotes = (lines) => {
        const padding = 10;
        const width = patchNotesCanvas.width;
        const height = patchNotesCanvas.height;

        // Clear the canvas
        ctx.clearRect(0, 0, width, height);

        // Set default styles
        ctx.fillStyle = 'white';
        ctx.font = '16px minecraft';

        // Pixel perfect rendering
        ctx.antialias = 'none'; // Text
        ctx.textBaseline = 'top';
        ctx.quality = 'best';
        ctx.textRendering = "optimizeLegibility";
        ctx.imageSmoothingEnabled = false; // Images

        const lineHeight = ctx.measureText('M').width * 1.5;

        // Define color codes and decorations
        const COLORS = {
            '&a': '#55FF55', '&b': '#55FFFF', '&c': '#FF5555', '&d': '#FF55FF', '&e': '#FFFF55', '&f': '#FFFFFF',
            '&0': '#000000', '&1': '#0000AA', '&2': '#00AA00', '&3': '#00AAAA', '&4': '#AA0000', '&5': '#AA00AA',
            '&6': '#FFAA00', '&7': '#AAAAAA', '&8': '#555555', '&9': '#5555FF',

            '&g': "#AA55FF"
        };

        const DECORATIONS = {
            '&l': 'bold', '&m': 'strikethrough', '&n': 'underline', '&o': 'italic',
        };

        const PREFIXES = {
            '!': '&3Patch:&e&l ',
            '@': '&aReleased: ',
            '#': '&e&l',
            '>': '&3→ &6',
            '+': '&a+ &6',
            '*': '&g+ &6',
            '~': '&d≈ &6',
            '-': '&c- &6',
            '^': '&b↑ &6',
        };

        // Iterate over each line of the patch notes
        let y = padding;
        for (let i = 0; i < lines.length; i++) {
            let x = padding;

            // Replace line prefixes with corresponding formatted text
            for (const prefix in PREFIXES) {
                if (lines[i].startsWith(prefix)) {
                    // Remove prefix and the space after it
                    lines[i] = PREFIXES[prefix] + lines[i].slice(2);
                }
            }

            // Reset styles for each line
            ctx.fillStyle = '#FFAA00';
            ctx.font = '16px minecraft';
            let currentDecoration = '';

            // Process each character in the line
            for (let j = 0; j < lines[i].length; j++) {
                if (lines[i][j] === '&') {
                    const code = lines[i].slice(j, j + 2);

                    if (COLORS[code]) {
                        ctx.fillStyle = COLORS[code];
                        ctx.font = '16px minecraft';
                        currentDecoration = '';
                        j++;
                        continue;
                    }

                    if (DECORATIONS[code]) {
                        currentDecoration += ' ' + DECORATIONS[code];
                        j++;
                        continue;
                    }

                    if (code === '&r') {
                        ctx.fillStyle = '#FFAA00';
                        currentDecoration = '';
                        j++;
                        continue;
                    }
                }

                if (currentDecoration.includes('underline')) {
                    ctx.strokeStyle = ctx.fillStyle;
                    ctx.beginPath();
                    ctx.moveTo(x, y + 15);
                    ctx.lineTo(x + ctx.measureText(lines[i][j]).width, y + 15);
                    ctx.stroke();
                }

                if (currentDecoration.includes('strikethrough')) {
                    ctx.strokeStyle = ctx.fillStyle;
                    ctx.beginPath();
                    ctx.moveTo(x, y + 7);
                    ctx.lineTo(x + ctx.measureText(lines[i][j]).width, y + 7);
                    ctx.stroke();
                }

                // New line if the text exceeds the canvas width
                if (x + ctx.measureText(lines[i][j]).width > width - padding) {
                    x = padding;
                    y += padding + lineHeight;
                }

                ctx.font = `${currentDecoration.trim()} 16px minecraft`;
                const fillStyle = ctx.fillStyle;
                ctx.fillStyle = darkenHexColor(fillStyle, 85);
                ctx.fillText(lines[i][j], x + 3, y + 3);
                ctx.fillStyle = fillStyle;
                ctx.fillText(lines[i][j], x, y);
                x += ctx.measureText(lines[i][j]).width;
            }
            y = y + padding + lineHeight;
        }

        // Export the canvas as an image
        const image = patchNotesCanvas.toDataURL();
        console.log(image);
    };
</script>
</body>
</html>
